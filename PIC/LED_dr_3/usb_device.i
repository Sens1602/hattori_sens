#line 1 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 1 "../i_PSD_program/Microchip/USB/usb_device.c"

#line 153 "../i_PSD_program/Microchip/USB/usb_device.c"
 


#line 241 "../i_PSD_program/Microchip/USB/usb_device.c"
 

 

#line 1 "HardwareProfile.h"

#line 3 "HardwareProfile.h"
 


#line 7 "HardwareProfile.h"
#line 9 "HardwareProfile.h"
#line 10 "HardwareProfile.h"
#line 11 "HardwareProfile.h"



#line 15 "HardwareProfile.h"
#line 17 "HardwareProfile.h"
#line 18 "HardwareProfile.h"
#line 19 "HardwareProfile.h"

 

#line 23 "HardwareProfile.h"
#line 24 "HardwareProfile.h"
    
 

#line 28 "HardwareProfile.h"
#line 29 "HardwareProfile.h"

#line 31 "HardwareProfile.h"
#line 32 "HardwareProfile.h"

#line 34 "HardwareProfile.h"
#line 35 "HardwareProfile.h"

#line 37 "HardwareProfile.h"
#line 38 "HardwareProfile.h"

#line 40 "HardwareProfile.h"
#line 41 "HardwareProfile.h"

  
 
#line 45 "HardwareProfile.h"

 
#line 48 "HardwareProfile.h"
#line 49 "HardwareProfile.h"
#line 50 "HardwareProfile.h"
#line 51 "HardwareProfile.h"
#line 52 "HardwareProfile.h"
#line 53 "HardwareProfile.h"
#line 54 "HardwareProfile.h"
#line 55 "HardwareProfile.h"
#line 56 "HardwareProfile.h"
#line 245 "../i_PSD_program/Microchip/USB/usb_device.c"


#line 1 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 87 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
 
#line 1 "usb_config.h"

#line 3 "usb_config.h"
 


#line 7 "usb_config.h"

 
#line 10 "usb_config.h"
								
								
								
								
								
									
#line 17 "usb_config.h"




#line 22 "usb_config.h"
#line 23 "usb_config.h"



#line 27 "usb_config.h"
#line 28 "usb_config.h"
#line 29 "usb_config.h"

#line 31 "usb_config.h"

 
#line 34 "usb_config.h"

#line 36 "usb_config.h"


#line 39 "usb_config.h"




#line 44 "usb_config.h"
#line 45 "usb_config.h"
                                                
                                                



#line 51 "usb_config.h"

#line 53 "usb_config.h"


#line 56 "usb_config.h"


 
#line 60 "usb_config.h"

 
#line 63 "usb_config.h"

 
#line 66 "usb_config.h"
#line 67 "usb_config.h"
#line 68 "usb_config.h"

#line 70 "usb_config.h"
#line 71 "usb_config.h"
#line 72 "usb_config.h"
#line 73 "usb_config.h"

#line 75 "usb_config.h"



#line 79 "usb_config.h"
 

#line 82 "usb_config.h"
#line 88 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"


 
#line 92 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 93 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 94 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

 
#line 97 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 98 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 99 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"


typedef union
{
    struct
    {
        unsigned char ping_pong_state :1;
        unsigned char transfer_terminated :1;
    } bits;
    BYTE Val;
} EP_STATUS;

#line 112 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 113 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 114 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 115 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 116 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 117 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 118 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 119 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 120 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 121 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 122 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 123 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 124 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 125 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 126 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 127 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 128 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 129 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 130 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 131 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 132 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 133 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 134 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 135 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 136 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 137 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 138 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 139 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 140 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 141 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 142 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 143 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 144 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 145 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 146 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 147 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 148 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 149 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 150 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 151 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 152 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 153 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 154 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 155 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 156 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 157 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 158 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 159 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 160 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 161 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 162 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 163 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 164 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 165 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 166 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 167 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 168 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 169 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 170 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 171 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 172 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 173 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 174 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 175 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 176 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 177 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 178 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 179 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 181 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 182 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 184 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 256 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 257 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 258 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 262 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 266 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 267 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 271 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 273 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 341 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 342 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 344 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 346 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 347 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 349 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 351 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 353 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 425 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 427 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"


#line 432 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
 
#line 434 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 438 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 439 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 440 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 442 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 446 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 447 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 448 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 450 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 452 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 453 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 454 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 456 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 458 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 459 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 460 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 462 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 464 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 465 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 466 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 468 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 470 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 471 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 472 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 474 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 476 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 477 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 478 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 480 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 482 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 483 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 484 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 486 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 488 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 489 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"
#line 490 "../i_PSD_program/Microchip/USB/../USB/usb_device_local.h"

#line 247 "../i_PSD_program/Microchip/USB/usb_device.c"



#line 251 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 253 "../i_PSD_program/Microchip/USB/usb_device.c"

#line 255 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 256 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 257 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 258 "../i_PSD_program/Microchip/USB/usb_device.c"

 

 
#pragma udata

USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
USB_VOLATILE BYTE USBActiveConfiguration;
USB_VOLATILE BYTE USBAlternateInterface[1 ];
volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
volatile BDT_ENTRY *pBDTEntryEP0OutNext;
volatile BDT_ENTRY *pBDTEntryOut[2 +1];
volatile BDT_ENTRY *pBDTEntryIn[2 +1];
USB_VOLATILE BYTE shortPacketStatus;
USB_VOLATILE BYTE controlTransferState;
USB_VOLATILE IN_PIPE inPipes[1];
USB_VOLATILE OUT_PIPE outPipes[1];
USB_VOLATILE BYTE *pDst;
USB_VOLATILE BOOL RemoteWakeup;
USB_VOLATILE BOOL USBBusIsSuspended;
USB_VOLATILE USTAT_FIELDS USTATcopy;
USB_VOLATILE BYTE endpoint_number;
USB_VOLATILE BOOL BothEP0OutUOWNsSet;
USB_VOLATILE EP_STATUS ep_data_in[2 +1];
USB_VOLATILE EP_STATUS ep_data_out[2 +1];
USB_VOLATILE BYTE USBStatusStageTimeoutCounter;
volatile BOOL USBDeferStatusStagePacket;
volatile BOOL USBStatusStageEnabledFlag1;
volatile BOOL USBStatusStageEnabledFlag2;
volatile BOOL USBDeferINDataStagePackets;
volatile BOOL USBDeferOUTDataStagePackets;


 
#line 293 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 294 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 296 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 298 "../i_PSD_program/Microchip/USB/usb_device.c"
        #pragma udata USB_BDT=0x400     
#line 300 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 301 "../i_PSD_program/Microchip/USB/usb_device.c"


#line 307 "../i_PSD_program/Microchip/USB/usb_device.c"
 
#line 309 "../i_PSD_program/Microchip/USB/usb_device.c"
    volatile BDT_ENTRY BDT[(2  + 1) * 2] __attribute__ ((aligned (512)));
#line 311 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 313 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 315 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 317 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 319 "../i_PSD_program/Microchip/USB/usb_device.c"


#line 322 "../i_PSD_program/Microchip/USB/usb_device.c"
 
volatile CTRL_TRF_SETUP SetupPkt;           
volatile BYTE CtrlTrfData[8 ];


#line 328 "../i_PSD_program/Microchip/USB/usb_device.c"
 

#line 331 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 334 "../i_PSD_program/Microchip/USB/usb_device.c"

#line 336 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 342 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 344 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 346 "../i_PSD_program/Microchip/USB/usb_device.c"

#line 348 "../i_PSD_program/Microchip/USB/usb_device.c"
#pragma udata
#line 350 "../i_PSD_program/Microchip/USB/usb_device.c"


#line 353 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 356 "../i_PSD_program/Microchip/USB/usb_device.c"
    extern ROM USB_DEVICE_DESCRIPTOR device_dsc ;
#line 358 "../i_PSD_program/Microchip/USB/usb_device.c"

#line 360 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 363 "../i_PSD_program/Microchip/USB/usb_device.c"
    extern ROM BYTE *ROM USB_CD_Ptr[] ;
#line 365 "../i_PSD_program/Microchip/USB/usb_device.c"

extern ROM BYTE *ROM USB_SD_Ptr[];

 
#pragma code

 

 


BOOL USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, WORD size);


static void USBCtrlEPService(void);
static void USBCtrlTrfSetupHandler(void);
static void USBCtrlTrfInHandler(void);
static void USBCheckStdRequest(void);
static void USBStdGetDscHandler(void);
static void USBCtrlEPServiceComplete(void);
static void USBCtrlTrfTxService(void);
static void USBCtrlTrfRxService(void);
static void USBStdSetCfgHandler(void);
static void USBStdGetStatusHandler(void);
static void USBStdFeatureReqHandler(void);
static void USBCtrlTrfOutHandler(void);
static void USBConfigureEndpoint(BYTE EPNum, BYTE direction);
static void USBWakeFromSuspend(void);
static void USBSuspend(void);
static void USBStallHandler(void);






 
 
 



#line 428 "../i_PSD_program/Microchip/USB/usb_device.c"
 

#line 431 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 432 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 433 "../i_PSD_program/Microchip/USB/usb_device.c"



#line 456 "../i_PSD_program/Microchip/USB/usb_device.c"
 

void USBDeviceInit(void)
{
    BYTE i;

    USBDisableInterrupts();

    
    USBClearInterruptRegister(U1EIR);  
       
    
    USBClearInterruptRegister(U1IR); 

    
    U1EP0 = 0;
    DisableNonZeroEndpoints(2 );

    SetConfigurationOptions();

    
    USBPowerModule();

    
    USBSetBDTAddress(BDT);

    
    for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
    {
        BDT[i].Val = 0x00;
    }

    
    USBPingPongBufferReset = 1;                    

    
    U1ADDR = 0x00;                   

    
    USBPacketDisable = 0;           

    
    USBPingPongBufferReset = 0;

    
    while(USBTransactionCompleteIF == 1)      
    {
        USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
        
        inPipes[0].info.Val = 0;
        outPipes[0].info.Val = 0;
        outPipes[0].wCount.Val = 0;
    }

    
    
    USBStatusStageEnabledFlag1 = TRUE;  
    USBStatusStageEnabledFlag2 = TRUE;
    
    USBDeferINDataStagePackets = FALSE;
    USBDeferOUTDataStagePackets = FALSE;
    USBBusIsSuspended = FALSE;

	
	
	for(i = 0; i < (BYTE)(2 +1u); i++)
	{
		pBDTEntryIn[i] = 0u;
		pBDTEntryOut[i] = 0u;		
		ep_data_in[i].Val = 0u;
        ep_data_out[i].Val = 0u;
	}

    
    pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[1 ];
    
    U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
	
    BDT[0 ].ADR = ConvertToPhysicalAddress(&SetupPkt);
    BDT[0 ].CNT = 8 ;
    BDT[0 ].STAT.Val = _USIE|_DAT0|_BSTALL;

    
    USBActiveConfiguration = 0;     

    
    USBDeviceState = DETACHED_STATE;
}



#line 575 "../i_PSD_program/Microchip/USB/usb_device.c"
 


#line 579 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 580 "../i_PSD_program/Microchip/USB/usb_device.c"
    void USBDeviceTasks(void)
#line 582 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 584 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 586 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 587 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 589 "../i_PSD_program/Microchip/USB/usb_device.c"
{
    BYTE i;

#line 611 "../i_PSD_program/Microchip/USB/usb_device.c"

#line 613 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 647 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 651 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 675 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 698 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 700 "../i_PSD_program/Microchip/USB/usb_device.c"

    if(USBDeviceState == ATTACHED_STATE)
    {
        
#line 710 "../i_PSD_program/Microchip/USB/usb_device.c"
 

        if(!USBSE0Event)
        {
            USBClearInterruptRegister(U1IR);
#line 716 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 718 "../i_PSD_program/Microchip/USB/usb_device.c"
            USBResetIE = 1;             
            USBIdleIE = 1;             
            USBDeviceState = POWERED_STATE;
        }
    }

#line 734 "../i_PSD_program/Microchip/USB/usb_device.c"

    
#line 737 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    if(USBActivityIF && USBActivityIE)
    {
        USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
#line 742 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 744 "../i_PSD_program/Microchip/USB/usb_device.c"
            USBWakeFromSuspend();
#line 746 "../i_PSD_program/Microchip/USB/usb_device.c"
    }

    
#line 750 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    if(USBSuspendControl==1)
    {
        USBClearUSBInterrupt();
        return;
    }

    
#line 766 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    if(USBResetIF && USBResetIE)
    {
        USBDeviceInit();

        
        
        USBUnmaskInterrupts();

        USBDeviceState = DEFAULT_STATE;

#line 784 "../i_PSD_program/Microchip/USB/usb_device.c"

        USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
    }

    
#line 790 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    if(USBIdleIF && USBIdleIE)
    { 
#line 797 "../i_PSD_program/Microchip/USB/usb_device.c"
            USBSuspend();
#line 799 "../i_PSD_program/Microchip/USB/usb_device.c"
        
        USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
    }

    if(USBSOFIF)
    {
        if(USBSOFIE)
        {
            USER_USB_CALLBACK_EVENT_HANDLER(EVENT_SOF,0,1) ;
        }    
        USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
        
#line 812 "../i_PSD_program/Microchip/USB/usb_device.c"
            
#line 814 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 815 "../i_PSD_program/Microchip/USB/usb_device.c"
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
#line 832 "../i_PSD_program/Microchip/USB/usb_device.c"
            
            
            if(USBStatusStageTimeoutCounter != 0u)
            {
                USBStatusStageTimeoutCounter--;
            }
            
            
            
            
            
            if(USBStatusStageTimeoutCounter == 0)
            {
                USBCtrlEPAllowStatusStage();    
            } 
#line 848 "../i_PSD_program/Microchip/USB/usb_device.c"
    }

    if(USBStallIF && USBStallIE)
    {
        USBStallHandler();
    }

    if(USBErrorIF && USBErrorIE)
    {
        USER_USB_CALLBACK_EVENT_HANDLER(EVENT_BUS_ERROR,0,1) ;
        USBClearInterruptRegister(U1EIR);               

        
        
        
#line 864 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 866 "../i_PSD_program/Microchip/USB/usb_device.c"
    }

    
#line 872 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    if(USBDeviceState < DEFAULT_STATE)
    {
	    USBClearUSBInterrupt();
	    return; 
	}  

    
#line 881 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    if(USBTransactionCompleteIE)
    {
	    for(i = 0; i < 4u; i++)	
		{						
		    if(USBTransactionCompleteIF)
		    {
    		    
                USTATcopy.Val = U1STAT;
                endpoint_number = USBHALGetLastEndpoint(USTATcopy);
                
                USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
                
                
                
#line 897 "../i_PSD_program/Microchip/USB/usb_device.c"
                    if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
                    {
                        ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
                    }   
                    else
                    {
                        ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
                    }         
#line 906 "../i_PSD_program/Microchip/USB/usb_device.c"
                
                
                
                if(endpoint_number == 0)
                {
                    USBCtrlEPService();
                }
                else
                {
                    USER_USB_CALLBACK_EVENT_HANDLER(EVENT_TRANSFER,(BYTE*)&USTATcopy.Val,0) ;
                }
		    }
		    else
		    	break;	
		}
	}

    USBClearUSBInterrupt();
}


#line 941 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBStallHandler(void)
{
    
#line 952 "../i_PSD_program/Microchip/USB/usb_device.c"
 

     
    if(U1EP0bits.EPSTALL == 1)
    {
        
        if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
        {
            
            pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
        }
        U1EP0bits.EPSTALL = 0;               
    }

    USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
}


#line 984 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBSuspend(void)
{
    
#line 1009 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    USBActivityIE = 1;                     
    USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);

#line 1014 "../i_PSD_program/Microchip/USB/usb_device.c"
    U1CONbits.SUSPND = 1;                   
                                            
#line 1017 "../i_PSD_program/Microchip/USB/usb_device.c"
    USBBusIsSuspended = TRUE;
 
    
#line 1023 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    USER_USB_CALLBACK_EVENT_HANDLER(EVENT_SUSPEND,0,0) ;
}


#line 1041 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBWakeFromSuspend(void)
{
    USBBusIsSuspended = FALSE;

    
#line 1049 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    USER_USB_CALLBACK_EVENT_HANDLER(EVENT_RESUME,0,0) ;

#line 1053 "../i_PSD_program/Microchip/USB/usb_device.c"
        
        
        
        
        U1CONbits.SUSPND = 0;   
                                
#line 1060 "../i_PSD_program/Microchip/USB/usb_device.c"


    USBActivityIE = 0;

    
#line 1076 "../i_PSD_program/Microchip/USB/usb_device.c"
 

    
#line 1080 "../i_PSD_program/Microchip/USB/usb_device.c"
    while(USBActivityIF)
#line 1082 "../i_PSD_program/Microchip/USB/usb_device.c"
    {
        USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
    }  

}


#line 1108 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBCtrlEPService(void)
{
    
    
    
#line 1115 "../i_PSD_program/Microchip/USB/usb_device.c"
        USBStatusStageTimeoutCounter = (BYTE)45 ;
#line 1117 "../i_PSD_program/Microchip/USB/usb_device.c"
	
	
    if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
    {
		
#line 1123 "../i_PSD_program/Microchip/USB/usb_device.c"
            pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
#line 1125 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 1127 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 1129 "../i_PSD_program/Microchip/USB/usb_device.c"

		
        pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
		
        ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= 0x0000 ;

		
        if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
        {
            unsigned char setup_cnt;

	        
	        
	        
	        
            for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) 
            {
                *(BYTE*)((BYTE*)&SetupPkt + setup_cnt) = *(BYTE*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
                pBDTEntryEP0OutCurrent->ADR++;
            }    
            pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);

			
            USBCtrlTrfSetupHandler();
        }
        else
        {
			
            USBCtrlTrfOutHandler();
        }
    }
    else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
    {
		
		
        USBCtrlTrfInHandler();
    }

}


#line 1208 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBCtrlTrfSetupHandler(void)
{
    
    
    
    shortPacketStatus = 0 ;  
    USBDeferStatusStagePacket = FALSE;
    USBDeferINDataStagePackets = FALSE;
    USBDeferOUTDataStagePackets = FALSE;
    BothEP0OutUOWNsSet = FALSE;    
    controlTransferState = 0 ;

    
    
    
    
    
    
    
    pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
    ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= 0x0000 ;
    pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
    ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= 0x0000 ;
    pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         

    inPipes[0].info.Val = 0;
    inPipes[0].wCount.Val = 0;
    outPipes[0].info.Val = 0;
    outPipes[0].wCount.Val = 0;
    

    
    
    
    USBCheckStdRequest();                                               
    USER_USB_CALLBACK_EVENT_HANDLER(EVENT_EP0_REQUEST,0,0) ; 


    
    
    
    
    
    
    
    
    
    
    USBCtrlEPServiceComplete();
}



#line 1280 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBCtrlTrfOutHandler(void)
{
    if(controlTransferState == 2 )
    {
        USBCtrlTrfRxService();	
    }
    else 
    {
        
        
        controlTransferState = 0 ;

	    
	    
	    
	    
	    
		if(BothEP0OutUOWNsSet == FALSE)
		{
	        pBDTEntryEP0OutNext->CNT = 8 ;
	        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
	        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;			
		}
		else
		{
			BothEP0OutUOWNsSet = FALSE;
		}
    }
}


#line 1333 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBCtrlTrfInHandler(void)
{
    BYTE lastDTS;

    lastDTS = pBDTEntryIn[0]->STAT.DTS;

    
    ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= 0x0000 ;

    
    
    
    if(USBDeviceState == ADR_PENDING_STATE)
    {
        U1ADDR = SetupPkt.bDevADR.Val;
        if(U1ADDR != 0u)
        {
            USBDeviceState=ADDRESS_STATE;
        }
        else
        {
            USBDeviceState=DEFAULT_STATE;
        }
    }


    if(controlTransferState == 1 )
    {
        pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
        USBCtrlTrfTxService();

        
        
        
        
        if(shortPacketStatus == 2 )
        {
            
            
            pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
        }
        else
        {
            if(lastDTS == 0)
            {
                pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
            }
            else
            {
                pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|_DTSEN;
            }
        }
    }
	else 
	{
        
        
        
        if(outPipes[0].info.bits.busy == 1)
        {
            if(outPipes[0].pFunc != NULL)
            {
                outPipes[0].pFunc();
            }
            outPipes[0].info.bits.busy = 0;
        }
    	
        controlTransferState = 0 ;
        
        
	}	

}



#line 1424 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBCheckStdRequest(void)
{
    if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;

    switch(SetupPkt.bRequest)
    {
        case USB_REQUEST_SET_ADDRESS:
            inPipes[0].info.bits.busy = 1;            
            USBDeviceState = ADR_PENDING_STATE;       
             
            break;
        case USB_REQUEST_GET_DESCRIPTOR:
            USBStdGetDscHandler();
            break;
        case USB_REQUEST_SET_CONFIGURATION:
            USBStdSetCfgHandler();
            break;
        case USB_REQUEST_GET_CONFIGURATION:
            inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         
            inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               
            inPipes[0].wCount.v[0] = 1;                         
            inPipes[0].info.bits.busy = 1;
            break;
        case USB_REQUEST_GET_STATUS:
            USBStdGetStatusHandler();
            break;
        case USB_REQUEST_CLEAR_FEATURE:
        case USB_REQUEST_SET_FEATURE:
            USBStdFeatureReqHandler();
            break;
        case USB_REQUEST_GET_INTERFACE:
            inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface[SetupPkt.bIntfID];  
            inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               
            inPipes[0].wCount.v[0] = 1;                         
            inPipes[0].info.bits.busy = 1;
            break;
        case USB_REQUEST_SET_INTERFACE:
            inPipes[0].info.bits.busy = 1;
            USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
            break;
        case USB_REQUEST_SET_DESCRIPTOR:
            USER_USB_CALLBACK_EVENT_HANDLER(EVENT_SET_DESCRIPTOR,0,0) ;
            break;
        case USB_REQUEST_SYNCH_FRAME:
        default:
            break;
    }
}


#line 1492 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBStdFeatureReqHandler(void)
{
    BDT_ENTRY *p;
    EP_STATUS current_ep_data;
#line 1498 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 1500 "../i_PSD_program/Microchip/USB/usb_device.c"
        unsigned char* pUEP;             
#line 1502 "../i_PSD_program/Microchip/USB/usb_device.c"
    

#line 1536 "../i_PSD_program/Microchip/USB/usb_device.c"

    
    if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
       (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
    {
        inPipes[0].info.bits.busy = 1;
        if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
            RemoteWakeup = TRUE;
        else
            RemoteWakeup = FALSE;
    }

    
    if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
       (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
       (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= 2 )&&
       (USBDeviceState == CONFIGURED_STATE))
    {
		
		
		inPipes[0].info.bits.busy = 1;

        
        if(SetupPkt.EPDir == OUT_FROM_HOST)
        {
            p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
            current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
        }
        else
        {
            p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
            current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
        }

        
        
        
#line 1574 "../i_PSD_program/Microchip/USB/usb_device.c"
            if(current_ep_data.bits.ping_pong_state == 0) 
            {
                {((BYTE_VAL*)&p)->Val &= ~0x0000 ;} ;
            }
            else 
            {
                {((BYTE_VAL*)&p)->Val |= 0x0000 ;} ;
            }
#line 1583 "../i_PSD_program/Microchip/USB/usb_device.c"
        
        
        
        if(SetupPkt.EPDir == OUT_FROM_HOST)
        {
            pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
        }
        else
        {
            pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
        }

		
        if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
        {
            if(p->STAT.UOWN == 1)
            {
                
                
                if(SetupPkt.EPDir == OUT_FROM_HOST)
                {
                    ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
                }
                else
                {
                    ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
                }
            }

			
            p->STAT.Val |= _USIE|_BSTALL;
        }
        else
        {
			
#line 1619 "../i_PSD_program/Microchip/USB/usb_device.c"
                
                ((BYTE_VAL*)&p)->Val ^= 0x0000 ; ;  

                if(p->STAT.UOWN == 1)
                {
                    
                    
                    p->STAT.Val &= (~_USIE);    
                    p->STAT.Val |= _DAT1;       
                    USER_USB_CALLBACK_EVENT_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p)) ;
                }
                else
                {
                    
					p->STAT.Val |= _DAT1;
                }

                
                
                ((BYTE_VAL*)&p)->Val ^= 0x0000 ; ;    
                
                
                
                
                
                if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
                {
                    if(SetupPkt.EPDir == OUT_FROM_HOST)
                    {
                        ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
                    }
                    else
                    {
                        ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
                    }
                    
                    p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
                    
					
                    USER_USB_CALLBACK_EVENT_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p)) ;
                }
                else
                {
                    
                    p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
                } 
#line 1666 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 1705 "../i_PSD_program/Microchip/USB/usb_device.c"
            
			
#line 1708 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 1711 "../i_PSD_program/Microchip/USB/usb_device.c"
                pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
#line 1713 "../i_PSD_program/Microchip/USB/usb_device.c"

			
            *pUEP &= ~UEP_STALL;            
        }
    }
}



#line 1750 "../i_PSD_program/Microchip/USB/usb_device.c"
 
void USBCtrlEPAllowStatusStage(void)
{
    
    
    
    
    
    if(USBStatusStageEnabledFlag1 == FALSE)
    {
        USBStatusStageEnabledFlag1 = TRUE;  
        if(USBStatusStageEnabledFlag2 == FALSE)
        {
            USBStatusStageEnabledFlag2 = TRUE;
        
            
            
            if(controlTransferState == 2 )
            {
                pBDTEntryIn[0]->CNT = 0;
                pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;        
            }
            else if(controlTransferState == 1 )
            {
        		BothEP0OutUOWNsSet = FALSE;	
        
                
                
#line 1779 "../i_PSD_program/Microchip/USB/usb_device.c"
        		pBDTEntryEP0OutCurrent->CNT = 8 ;
        		pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
        		pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_BSTALL; 
        		BothEP0OutUOWNsSet = TRUE;	
#line 1784 "../i_PSD_program/Microchip/USB/usb_device.c"
        
                
        		pBDTEntryEP0OutNext->CNT = 8 ;
        		pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
        		pBDTEntryEP0OutNext->STAT.Val = _USIE;           
            }
        }    
    }
}   



#line 1820 "../i_PSD_program/Microchip/USB/usb_device.c"
 
void USBCtrlEPAllowDataStage(void)
{
    USBDeferINDataStagePackets = FALSE;
    USBDeferOUTDataStagePackets = FALSE;

    if(controlTransferState == 2 ) 
    {
        
        pBDTEntryEP0OutNext->CNT = 8 ;
        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
    }   
    else    
    {
        
        
		if(SetupPkt.wLength < inPipes[0].wCount.Val)
		{
			inPipes[0].wCount.Val = SetupPkt.wLength;
		}
		USBCtrlTrfTxService();  
		                        

	    
	    
		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
		pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|_DTSEN;
    }     
}    


#line 1866 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBStdGetDscHandler(void)
{
    if(SetupPkt.bmRequestType == 0x80)
    {
        inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;

        switch(SetupPkt.bDescriptorType)
        {
            case USB_DESCRIPTOR_DEVICE:
#line 1877 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 1879 "../i_PSD_program/Microchip/USB/usb_device.c"
                    inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc ;
#line 1881 "../i_PSD_program/Microchip/USB/usb_device.c"
                inPipes[0].wCount.Val = sizeof(device_dsc);
                break;
            case USB_DESCRIPTOR_CONFIGURATION:
#line 1885 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 1887 "../i_PSD_program/Microchip/USB/usb_device.c"
                    inPipes[0].pSrc.bRom = *(USB_CD_Ptr +SetupPkt.bDscIndex);
#line 1889 "../i_PSD_program/Microchip/USB/usb_device.c"

                
                
                
                inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
                inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
                break;
            case USB_DESCRIPTOR_STRING:
                
                
                
                if(SetupPkt.bDscIndex<3 )
                {
                    
                    inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
                    
                    inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
                }
                else
                {
                    inPipes[0].info.Val = 0;
                }
                break;
            default:
                inPipes[0].info.Val = 0;
                break;
        }
    }
}


#line 1933 "../i_PSD_program/Microchip/USB/usb_device.c"
 
void USBStdGetStatusHandler(void)
{
    CtrlTrfData[0] = 0;                 
    CtrlTrfData[1] = 0;

    switch(SetupPkt.Recipient)
    {
        case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
            inPipes[0].info.bits.busy = 1;
            
#line 1946 "../i_PSD_program/Microchip/USB/usb_device.c"
 
            if(1  == 1) 
            {
                CtrlTrfData[0]|=0x01;
            }

            if(RemoteWakeup == TRUE)
            {
                CtrlTrfData[0]|=0x02;
            }
            break;
        case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
            inPipes[0].info.bits.busy = 1;     
            break;
        case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
            inPipes[0].info.bits.busy = 1;
            
#line 1964 "../i_PSD_program/Microchip/USB/usb_device.c"
 
            {
                BDT_ENTRY *p;

                if(SetupPkt.EPDir == 0)
                {
                    p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
                }
                else
                {
                    p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
                }

                if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
                    CtrlTrfData[0]=0x01;    
                break;
            }
    }

    if(inPipes[0].info.bits.busy == 1)
    {
        inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            
        inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               
        inPipes[0].wCount.v[0] = 2;                         
    }
}


#line 2018 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBCtrlEPServiceComplete(void)
{
    
#line 2024 "../i_PSD_program/Microchip/USB/usb_device.c"
 
    USBPacketDisable = 0;

	
	
	
	
    if(inPipes[0].info.bits.busy == 0)
    {
        if(outPipes[0].info.bits.busy == 1)
        {
            controlTransferState = 2 ;
            
#line 2039 "../i_PSD_program/Microchip/USB/usb_device.c"
 

            
            
            
            
            
            if(USBDeferOUTDataStagePackets == FALSE)
            {
                USBCtrlEPAllowDataStage();
            }
            
            
            
            USBStatusStageEnabledFlag2 = FALSE;
            USBStatusStageEnabledFlag1 = FALSE;
        }
        else
        {
            
#line 2061 "../i_PSD_program/Microchip/USB/usb_device.c"
 
            pBDTEntryEP0OutNext->CNT = 8 ;
            pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
            pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
            pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
        }
    }
    else    
    {
		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
		{
			controlTransferState = 1 ;
			
#line 2085 "../i_PSD_program/Microchip/USB/usb_device.c"
 
			if(USBDeferINDataStagePackets == FALSE)
            {
                USBCtrlEPAllowDataStage();
			}

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            USBStatusStageEnabledFlag2 = FALSE;
            USBStatusStageEnabledFlag1 = FALSE;
            if(USBDeferStatusStagePacket == FALSE)
            {
                USBCtrlEPAllowStatusStage();
            } 
		}
		else   
		{
			
			
			
			
			
				
			
			
			

			controlTransferState = 2 ;     
			
			
			pBDTEntryEP0OutNext->CNT = 8 ;
			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
			pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
				
			
            USBStatusStageEnabledFlag2 = FALSE;
            USBStatusStageEnabledFlag1 = FALSE;
			if(USBDeferStatusStagePacket == FALSE)
            {
                USBCtrlEPAllowStatusStage();
            } 
		}

    }

}



#line 2170 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBCtrlTrfTxService(void)
{
    BYTE byteToSend;

    
    
    byteToSend = 8 ;         
    if(inPipes[0].wCount.Val < (BYTE)8 )
    {
        byteToSend = inPipes[0].wCount.Val;

        
        
        
        
        
        if(shortPacketStatus == 0 )
        {
            shortPacketStatus = 1 ;
        }
        else if(shortPacketStatus == 1 )
        {
            shortPacketStatus = 2 ;
        }
    }

    
    
    inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend;
    
    
    
    
    pBDTEntryIn[0]->CNT = byteToSend;

    
    
    pDst = (USB_VOLATILE BYTE*)CtrlTrfData;                
    if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   
    {
        while(byteToSend)
        {
            *pDst++ = *inPipes[0].pSrc.bRom++;
            byteToSend--;
        }
    }
    else  
    {
        while(byteToSend)
        {
            *pDst++ = *inPipes[0].pSrc.bRam++;
            byteToSend--;
        }
    }
}


#line 2251 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBCtrlTrfRxService(void)
{
    BYTE byteToRead;
    BYTE i;

    
    
    byteToRead = pBDTEntryEP0OutCurrent->CNT;   

    
    
    
    
    if(byteToRead > outPipes[0].wCount.Val)
    {
        byteToRead = outPipes[0].wCount.Val;
    }	
    
	outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;   

    
    
    for(i=0;i<byteToRead;i++)
    {
        *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
    }

    
	
    if(outPipes[0].wCount.Val > 0)
    {
        pBDTEntryEP0OutNext->CNT = 8 ;
        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
        if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
        {
            pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|_DTSEN;
        }
        else
        {
            pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN;
        }
    }
    else
    {
	    
	    
		
        pBDTEntryEP0OutNext->CNT = 8 ;
        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
        
        
        
        pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;

		
		
		
		
		
        if(outPipes[0].pFunc != NULL)
        {
            outPipes[0].pFunc();
        }
        outPipes[0].info.bits.busy = 0;    

        
        
        
        
        
        
        
        
        
        
        
        
        if(USBDeferStatusStagePacket == FALSE)
        {
            USBCtrlEPAllowStatusStage();
        }            
    }    

}



#line 2355 "../i_PSD_program/Microchip/USB/usb_device.c"
 
void USBStdSetCfgHandler(void)
{
    BYTE i;

    
    inPipes[0].info.bits.busy = 1;            

    
    DisableNonZeroEndpoints(2 );

    
    for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
    {
        BDT[i].Val = 0x00;
    }

    
    USBPingPongBufferReset = 1;                                   

	
	
	
	for(i = 0; i < (BYTE)(2 +1u); i++)
	{
		ep_data_in[i].Val = 0u;
        ep_data_out[i].Val = 0u;
	}

    
    memset((void*)&USBAlternateInterface,0x00,1 );

    
    USBPingPongBufferReset = 0;

    pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[1 ];

	
    pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[0 ];
    pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;

    
    USBActiveConfiguration = SetupPkt.bConfigurationValue;

    
    if(USBActiveConfiguration == 0)
    {
        
        USBDeviceState = ADDRESS_STATE;
    }
    else
    {
        
        USER_USB_CALLBACK_EVENT_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1) ;

        
        
        
        USBDeviceState = CONFIGURED_STATE;		
    }
}


#line 2434 "../i_PSD_program/Microchip/USB/usb_device.c"
 
static void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
{
    volatile BDT_ENTRY* handle;

    
    
    handle = (volatile BDT_ENTRY*)&BDT[0 ]; 
    handle += (2*EPNum+direction) ;     
    
    handle->STAT.UOWN = 0;  
    

    
    
    if(direction == OUT_FROM_HOST)
    {
        pBDTEntryOut[EPNum] = handle;
    }
    else
    {
        pBDTEntryIn[EPNum] = handle;
    }

#line 2459 "../i_PSD_program/Microchip/USB/usb_device.c"
        handle->STAT.DTS = 0;
        (handle+1)->STAT.DTS = 1;
#line 2462 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 2466 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 2471 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 2477 "../i_PSD_program/Microchip/USB/usb_device.c"
}


#line 2526 "../i_PSD_program/Microchip/USB/usb_device.c"
 
void USBEnableEndpoint(BYTE ep, BYTE options)
{
    unsigned char* p;
        
    
    
    if(options & USB_OUT_ENABLED)
    {
        USBConfigureEndpoint(ep, OUT_FROM_HOST);
    }
    if(options & USB_IN_ENABLED)
    {
        USBConfigureEndpoint(ep, IN_TO_HOST);
    }

    
    
    
#line 2546 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 2548 "../i_PSD_program/Microchip/USB/usb_device.c"
        p = (unsigned char*)(&U1EP0+ep);
#line 2550 "../i_PSD_program/Microchip/USB/usb_device.c"
    *p = options;
}


#line 2569 "../i_PSD_program/Microchip/USB/usb_device.c"
 
void USBStallEndpoint(BYTE ep, BYTE dir)
{
    BDT_ENTRY *p;

    if(ep == 0)
    {
        
        
        
        pBDTEntryEP0OutNext->CNT = 8 ;
        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|_DTSEN|_BSTALL;
        pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
               
    }
    else
    {
        p = (BDT_ENTRY*)(&BDT[(2*ep+dir) ]);
        p->STAT.Val |= _BSTALL | _USIE;
    
        
        
#line 2593 "../i_PSD_program/Microchip/USB/usb_device.c"
    
        p = (BDT_ENTRY*)(&BDT[(2*ep+dir) ]);
        p->STAT.Val |= _BSTALL | _USIE;
#line 2597 "../i_PSD_program/Microchip/USB/usb_device.c"
    }
}


#line 2674 "../i_PSD_program/Microchip/USB/usb_device.c"
 
USB_HANDLE USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
{
    volatile BDT_ENTRY* handle;

    
    if(dir != 0)
    {
        
        handle = pBDTEntryIn[ep];
    }
    else
    {
        
        handle = pBDTEntryOut[ep];
    }
    
    
    
    if(handle == 0)
    {
	    return 0;
	}

    
#line 2700 "../i_PSD_program/Microchip/USB/usb_device.c"
        handle->STAT.Val ^= _DTSMASK;
#line 2702 "../i_PSD_program/Microchip/USB/usb_device.c"
#line 2707 "../i_PSD_program/Microchip/USB/usb_device.c"

    
    handle->ADR = ConvertToPhysicalAddress(data);
    handle->CNT = len;
    handle->STAT.Val &= _DTSMASK;
    handle->STAT.Val |= _USIE | _DTSEN;

    
    if(dir != OUT_FROM_HOST)
    {
        
        ((BYTE_VAL*)&pBDTEntryIn[ep])->Val ^= 0x0000 ; ;      
    }
    else
    {
        
        ((BYTE_VAL*)&pBDTEntryOut[ep])->Val ^= 0x0000 ; ;     
    }
    return (USB_HANDLE)handle;
}


#line 2750 "../i_PSD_program/Microchip/USB/usb_device.c"
 
void USBCancelIO(BYTE endpoint)
{
    if(USBPacketDisable == 1)
    {
    	
    	
    	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	
    	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	
    	
    	
#line 2762 "../i_PSD_program/Microchip/USB/usb_device.c"
        
        
        
        ((BYTE_VAL*)&pBDTEntryIn[endpoint])->Val ^= 0x0000 ; ;       
    
    	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
    	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
#line 2770 "../i_PSD_program/Microchip/USB/usb_device.c"
    }
}


#line 2808 "../i_PSD_program/Microchip/USB/usb_device.c"
 
#line 2810 "../i_PSD_program/Microchip/USB/usb_device.c"
void USBDeviceDetach(void)
{
    
    
    
#line 2818 "../i_PSD_program/Microchip/USB/usb_device.c"
    {
         
         U1CON = 0;             

         
         U1IE = 0;          

         
         USBDeviceState = DETACHED_STATE;

#line 2848 "../i_PSD_program/Microchip/USB/usb_device.c"

#line 2852 "../i_PSD_program/Microchip/USB/usb_device.c"
            
            
          return;
    }

#line 2875 "../i_PSD_program/Microchip/USB/usb_device.c"
}
#line 2877 "../i_PSD_program/Microchip/USB/usb_device.c"

#line 2913 "../i_PSD_program/Microchip/USB/usb_device.c"
 
#line 2915 "../i_PSD_program/Microchip/USB/usb_device.c"
void USBDeviceAttach(void)
{
    
    if(USBDeviceState == DETACHED_STATE)
    {
        if(1  == 1)
        {
    	    
            U1CON = 0;          
    
            
            U1IE = 0;                                
    
            
            
            SetConfigurationOptions();
    
            USBEnableInterrupts();  
    
            
            while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
    
            
            USBDeviceState = ATTACHED_STATE;
    
#line 2943 "../i_PSD_program/Microchip/USB/usb_device.c"
        }
    }
}
#line 2947 "../i_PSD_program/Microchip/USB/usb_device.c"
 
